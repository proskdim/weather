package weather.code.services

import cats.effect.*
import doobie.*
import doobie.implicits.*

case object DataSourceProvider extends IOApp:
  case class User(id: Int, name: String)

  extension [A](io: IO[A])
    def dbg: IO[A] = io.map { a =>
      println(s"[${Thread.currentThread().getName}] $a")
      a
    }

  val xa: Transactor[IO] = Transactor.fromDriverManager[IO](
    "org.h2.Driver",
    "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1",
    None
  )

  def createUsersTable: IO[Int] =
    val query =
      sql"""
       CREATE TABLE IF NOT EXISTS users (
         id INT AUTO_INCREMENT PRIMARY KEY,
         name VARCHAR NOT NULL
       )
     """
    query.update.run.transact(xa)

  def insertUsers: IO[Int] =
    val query = sql"INSERT INTO users (name) VALUES ('Alice')"
    query.update.run.transact(xa)

  def findUsers: IO[List[User]] =
    val query = sql"select id, name from users".query[User]
    val action = query.stream.compile.toList
    action.transact(xa)

  // более оптимальный вариант
  def findUsersStream =
    sql"select name from users".query[String].stream.compile.toList.transact(xa)

  def findUserById(id: Int): IO[Option[User]] =
    val query = sql"select id, name from users where id=$id".query[User]
    val action = query.option
    action.transact(xa)

  // более низкоуровневый вариант
  def findUserByIdStream(id: Int): IO[Option[User]] =
    val queryString = "select id, name from users where id = ?"
    HC.stream[User](
      queryString,
      HPS.set(id),
      100 // кол-во записей которые мы извлекам (батч)
    ).compile
      .toList
      .map(_.headOption)
      .transact(xa)

  def saveUserAutoGenerated(name: String): IO[Int] =
    sql"insert into users (name) values ($name)".update
      .withUniqueGeneratedKeys[Int]("id")
      .transact(xa)

  def saveUser(id: Int, name: String): IO[Int] =
    val queryString = "insert into users (id, name) values (?, ?)"
    Update[User](queryString).run(User(id, name)).transact(xa)

  def saveMultipleUsers(userNames: List[String]): IO[List[User]] =
    val queryString = "insert into users (name) values (?)"
    val action = Update[String](queryString)
      .updateManyWithGeneratedKeys[User]("id", "name")(userNames)
    action.compile.toList.transact(xa)

  // doobie 2

  case class UserId(id: Int)
  case class UserName(name: String)
  case class UserCustom(id: UserId, userName: UserName)

  object UserCustom:
    implicit val userRead: Read[UserCustom] = Read[(Int, String)].map {
      case (id, name) => UserCustom(UserId(id), UserName(name))
    }

    implicit val userWrite: Write[UserCustom] = Write[(Int, String)].contramap {
      case UserCustom(UserId(id), UserName(name)) => (id, name)
    }

  def findAllUsers: IO[List[UserCustom]] = sql"select id, name from users"
    .query[UserCustom]
    .to[List]
    .transact(xa)

  override def run(args: List[String]): IO[ExitCode] =
    for
      _ <- createUsersTable
      _ <- insertUsers
      _ <- findUsers.dbg
      _ <- findUsersStream.dbg
      _ <- findUserById(1).dbg
      _ <- findUserById(2).dbg
      _ <- saveUserAutoGenerated("dima")
      _ <- findUserByIdStream(1).dbg
      _ <- findUserByIdStream(2).dbg
      _ <- saveUser(3, "Ann")
      _ <- findUsers.dbg
      _ <- saveMultipleUsers(List("Alex", "Alexander"))
      _ <- findUsers.dbg
      - <- findAllUsers.dbg
    yield ExitCode.Success
